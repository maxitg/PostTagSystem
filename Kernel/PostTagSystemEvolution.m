Package["PostTagSystem`"]

PackageImport["GeneralUtilities`"]

PackageExport["PostTagSystemEvolution"]

(* This is an object that is returned by PostTagSystem. It allows one to query the set at different generations and
   different steps. *)

SetUsage @ "
PostTagSystemEvolution[$$] is an evolution object generated by PostTagSystem.
PostTagSystemEvolution[$$]['Property', s$] yields the value of `Property` with arguments s$.
PostTagSystemEvolution[$$]['Properties'] yields the list of all available properties.
";

SyntaxInformation[PostTagSystemEvolution] = {"ArgumentsPattern" -> {___}};

(* MakeBoxes *)

PostTagSystemEvolution /:
    MakeBoxes[
      evolution_PostTagSystemEvolution ? ManagedLibraryExpressionQ,
      format_] := ModuleScope[
  BoxForm`ArrangeSummaryBox[
    PostTagSystemEvolution,
    evolution,
    ArrayPlot[{{1}, {1, 1, 0, 1}, {1, 1, 1, 0, 1}, {0, 1, 1, 1, 0, 1}, {1, 0, 1, 0, 0}, {0, 0, 1, 1, 0, 1}},
              ColorRules -> {0 -> White, 1 -> Darker @ Gray}],
    (* Always grid *)
    {"States: " <> ToString[evolution["StateCount"]]},
    (* Sometimes grid *)
    {},
    format,
    "Interpretable" -> Automatic
  ]
];

$propertyArgumentCounts = <|
  "EvolutionObject" -> {0, 0},
  "Properties" -> {0, 0},
  "StateCount" -> {0, 0},
  "StateGraph" -> {0, Infinity},
  "State" -> {1, 1},
  "CycleSources" -> {0, 0}|>;

(* Master options handling *)

(* Unknown property *)

General::unknownProperty = "Property `2` in `1` is not recognized."

propertyEvaluate[
    evolution : PostTagSystemEvolution[_Integer],
    property_,
    o___] /; !MemberQ[Keys[$propertyArgumentCounts], property] := (
  Message[PostTagSystemEvolution::unknownProperty, Defer[evolution[property, o]], property];
  Throw[$Failed]
);

(* Check property argument counts *)

General::pargx = "Property \"`1`\" requested with `2` argument`3`; `4``5``6``7` argument`8` `9` expected.";

makePargxMessage[property_, givenArgs_, expectedArgs_] := Message[
  PostTagSystemEvolution::pargx,
  property,
  givenArgs,
  If[givenArgs == 1, "", "s"],
  If[expectedArgs[[1]] != expectedArgs[[2]], "between ", ""],
  expectedArgs[[1]],
  If[expectedArgs[[1]] != expectedArgs[[2]], " and ", ""],
  If[expectedArgs[[1]] != expectedArgs[[2]], expectedArgs[[2]], ""],
  If[expectedArgs[[1]] != expectedArgs[[2]] || expectedArgs[[1]] != 1, "s", ""],
  If[expectedArgs[[1]] != expectedArgs[[2]] || expectedArgs[[1]] != 1, "are", "is"]
];

propertyEvaluate[
    PostTagSystemEvolution[id_Integer],
    property_String,
    args___] /;
      With[{argumentsCountRange = $propertyArgumentCounts[property]},
        Not[MissingQ[argumentsCountRange]] &&
        Not[argumentsCountRange[[1]] <= Length[{args}] <= argumentsCountRange[[2]]]] := (
  makePargxMessage[property, Length[{args}], $propertyArgumentCounts[property]];
  Throw[$Failed]
);

(* Check options *)

$propertyOptions = <|
|>;

(* Prevent {}, {{}}, {{}, {}}, etc. being treated as options *)
$nonEmptyOptionsPattern = OptionsPattern[] ? (AllTrue[{##}, Length[Flatten[{#}, Infinity]] > 0 &] &);

propertyEvaluate[
    evolution : PostTagSystemEvolution[_Integer],
    property : Alternatives @@ Keys[$propertyOptions],
    o : $nonEmptyOptionsPattern] := (
  Message[
    PostTagSystemEvolution::optx,
    First[Last[Complement[{o}, FilterRules[{o}, Options[$propertyOptions[property]]]]]],
    Defer[evolution[property, o]]];
  Throw[$Failed]
);

propertyEvaluate[
    evolution : PostTagSystemEvolution[_Integer],
    property : Alternatives @@ Keys[$propertyOptions],
    o___] := (
  Message[PostTagSystemEvolution::nonopt, Last[{o}], 1, Defer[evolution[property, o]]];
  Throw[$Failed]
);

(** Properties **)

propertyEvaluate[PostTagSystemEvolution[_Integer], "Properties"] := Keys[$propertyArgumentCounts];

(* EvolutionObject *)

propertyEvaluate[evolution : PostTagSystemEvolution[_Integer], "EvolutionObject"] := evolution;

(* StateCount *)

propertyEvaluate[PostTagSystemEvolution[id_Integer], "StateCount"] := cpp$stateCount[id];

(* StateGraph *)

propertyEvaluate[PostTagSystemEvolution[id_Integer], "StateGraph", opts : OptionsPattern[]] := ModuleScope[
  successors = cpp$stateSuccessors[id];
  states = Range[Length[successors]];
  Graph[states,
        DeleteCases[Thread[states -> successors], _ -> 0],
        opts,
        VertexStyle -> Directive[Opacity[0.7], Hue[0.62, 0.45, 0.87]],
        EdgeStyle -> Hue[0.75, 0, 0.35]]
]

(* State *)

propertyEvaluate[PostTagSystemEvolution[systemID_Integer], "State", stateID_Integer] :=
  Through[{First, Rest}[cpp$state[systemID, stateID]]]

(* Cycle sources *)

propertyEvaluate[PostTagSystemEvolution[systemID_Integer], "CycleSources"] := cpp$cycleSources[systemID];

(* Public properties call *)

(evolution : PostTagSystemEvolution[id_Integer])[args__] /; ManagedLibraryExpressionQ[evolution] := ModuleScope[
  result = Catch[propertyEvaluate[PostTagSystemEvolution[id], args]];
  result /; result =!= $Failed
];

(* Argument count *)

PostTagSystemEvolution[args___] := 0 /;
  !Developer`CheckArgumentCount[PostTagSystemEvolution[args], 1, 1] && False;

PostTagSystemEvolution[id_][] := 0 /;
  Message[PostTagSystemEvolution::argm, Defer[PostTagSystemEvolution[id][]], 0, 1];

(* Object exists *)

PostTagSystemEvolution::deallocated =
  "PostTagSystemEvolution `1` was deallocated or created in a different Wolfram Kernel session. " <>
  "You can only use evolution objects in the Wolfram Kernel session in which they were created.";

(evolution : PostTagSystemEvolution[_])[args___] /; !ManagedLibraryExpressionQ[evolution] := ModuleScope[
  Message[PostTagSystemEvolution::deallocated, Defer[evolution]];
  0 /; False
];
